import * as exec from '@actions/exec'
import * as core from '@actions/core'

/**
 * Create a new branch for the fix
 */
export async function createFixBranch(alertId: string): Promise<string> {
  const timestamp = Date.now()
  const sanitizedId = alertId.replace(/[^a-zA-Z0-9-]/g, '-').substring(0, 30)
  const branchName = `oncall-agent/fix-${sanitizedId}-${timestamp}`

  await exec.exec('git', ['checkout', '-b', branchName])

  return branchName
}

/**
 * Stage all changes made by Claude
 */
export async function stageChanges(): Promise<string[]> {
  // Get list of changed files
  let diffOutput = ''
  await exec.exec('git', ['diff', '--name-only'], {
    listeners: {
      stdout: (data: Buffer) => {
        diffOutput += data.toString()
      }
    },
    silent: true
  })

  // Get untracked files
  let untrackedOutput = ''
  await exec.exec('git', ['ls-files', '--others', '--exclude-standard'], {
    listeners: {
      stdout: (data: Buffer) => {
        untrackedOutput += data.toString()
      }
    },
    silent: true
  })

  const changedFiles = [
    ...diffOutput.trim().split('\n'),
    ...untrackedOutput.trim().split('\n')
  ].filter(Boolean)

  if (changedFiles.length > 0) {
    await exec.exec('git', ['add', ...changedFiles])
  }

  return changedFiles
}

/**
 * Commit the staged changes
 */
export async function commitChanges(
  alertTitle: string,
  alertSource: string
): Promise<boolean> {
  // Check if there are staged changes
  let statusOutput = ''
  await exec.exec('git', ['status', '--porcelain'], {
    listeners: {
      stdout: (data: Buffer) => {
        statusOutput += data.toString()
      }
    },
    silent: true
  })

  if (!statusOutput.trim()) {
    core.info('No changes to commit')
    return false
  }

  // Create commit
  const commitMessage = `fix: ${alertTitle}

Automated fix generated by oncall-agent in response to ${alertSource} alert.

ðŸ¤– Generated with oncall-agent`

  await exec.exec('git', ['commit', '-m', commitMessage])

  return true
}

/**
 * Push the branch to remote
 */
export async function pushBranch(branchName: string): Promise<void> {
  await exec.exec('git', ['push', '-u', 'origin', branchName])
}

/**
 * Get the current branch name
 */
export async function getCurrentBranch(): Promise<string> {
  let output = ''
  await exec.exec('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
    listeners: {
      stdout: (data: Buffer) => {
        output += data.toString()
      }
    },
    silent: true
  })
  return output.trim()
}

/**
 * Get the default branch name
 */
export async function getDefaultBranch(): Promise<string> {
  let output = ''
  try {
    await exec.exec('git', ['symbolic-ref', 'refs/remotes/origin/HEAD'], {
      listeners: {
        stdout: (data: Buffer) => {
          output += data.toString()
        }
      },
      silent: true,
      ignoreReturnCode: true
    })
    // Output is like refs/remotes/origin/main
    const match = output.match(/refs\/remotes\/origin\/(.+)/)
    if (match) {
      return match[1].trim()
    }
  } catch {
    // Fallback
  }
  return 'main'
}

/**
 * Check if there are uncommitted changes
 */
export async function hasUncommittedChanges(): Promise<boolean> {
  let output = ''
  await exec.exec('git', ['status', '--porcelain'], {
    listeners: {
      stdout: (data: Buffer) => {
        output += data.toString()
      }
    },
    silent: true
  })
  return output.trim().length > 0
}

/**
 * Discard all local changes
 */
export async function discardChanges(): Promise<void> {
  await exec.exec('git', ['checkout', '.'], { silent: true })
  await exec.exec('git', ['clean', '-fd'], { silent: true })
}

/**
 * Configure git for commits in CI
 */
export async function configureGit(): Promise<void> {
  await exec.exec('git', ['config', 'user.name', 'oncall-agent[bot]'], { silent: true })
  await exec.exec('git', ['config', 'user.email', 'oncall-agent[bot]@users.noreply.github.com'], { silent: true })
}

/**
 * Fetch and checkout a PR branch
 */
export async function checkoutPRBranch(prNumber: number): Promise<string> {
  // Fetch the PR
  await exec.exec('git', ['fetch', 'origin', `pull/${prNumber}/head:pr-${prNumber}`], { silent: true })

  // Checkout the PR branch
  await exec.exec('git', ['checkout', `pr-${prNumber}`], { silent: true })

  // Get the actual branch name from the PR
  let branchName = ''
  await exec.exec('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
    listeners: {
      stdout: (data: Buffer) => {
        branchName += data.toString()
      }
    },
    silent: true
  })

  return branchName.trim()
}

/**
 * Push changes to the PR branch
 */
export async function pushToPRBranch(prNumber: number, remoteBranch: string): Promise<void> {
  await exec.exec('git', ['push', 'origin', `HEAD:${remoteBranch}`], { silent: true })
}

/**
 * Commit changes for a PR review response
 */
export async function commitReviewChanges(commentSummary: string): Promise<boolean> {
  // Check if there are staged changes
  let statusOutput = ''
  await exec.exec('git', ['status', '--porcelain'], {
    listeners: {
      stdout: (data: Buffer) => {
        statusOutput += data.toString()
      }
    },
    silent: true
  })

  if (!statusOutput.trim()) {
    core.info('No changes to commit')
    return false
  }

  // Truncate comment summary for commit message
  const summary = commentSummary.length > 50
    ? commentSummary.substring(0, 47) + '...'
    : commentSummary

  const commitMessage = `fix: address review feedback

${summary}

ðŸ¤– Generated with oncall-agent in response to PR review`

  await exec.exec('git', ['commit', '-m', commitMessage])

  return true
}
